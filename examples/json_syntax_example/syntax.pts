ClearScanner()
ClearParser()

AddScannerRule( |>
  Result: TokenKeyword,
  BaseRule: fun(r) {
    return (((r >= "a") * (r <= "z")) + ((r >= "A") * (r <= "Z")) + (r == "_"))
  },
  Process: fun(mappings, runs) {
      if (Object.Has)(mappings, runs) {
    	return |> Type: TokenKeyword, Value: mappings[runs] <|
      } else {
        return |> Type: TokenIdentifier, Value: runs <|
      }
  },
  Mappings: |> "false": "FALSE", "true": "TRUE", "null": "NULL" <|
<| )

 AddScannerRule( |>
  Result: TokenSpace,
  Skip: true,
  BaseRule: fun(r) { return (( r == " ") + (r == "\n") + (r == "\r") + (r == "\t")) }
<| )

 AddScannerRule( |>
	Result:   TokenNumber,
	BaseRule: fun (r) = ((r >= "0") * (r <= "9"))
<| )

AddScannerRule( |>
	Result: TokenOperator,
	Process: fun (mappings, runs) {
      if ((Object.Has)(mappings, runs)) {
    	return |> Type: TokenOperator, Value: mappings[runs] <|
      } else {
        raise "invalid operator"
      }
	},
	ValidChars: ["{},:[]"],
	Mappings: |>
		"{": "LEFT_BRACE", "}": "RIGHT_BRACE",
		"[": "LEFT_BRACKET", "]": "RIGHT_BRACKET",
		":": "COLON", ",": "COMMA"
	<|
<| )

 AddScannerRule( |>
 	Result: TokenString,
 	BaseRule: fun (r) = true,
 	Rule: fun (runs) {
 		let len = (String.Length)(runs)
 		let last = len - 1

 		let lastChar = (String.At)(runs, last)

 		return ((len == 1) + ((lastChar == `"`) == false))
 	},
 	Process: fun(mappings, runs) {
	 		let len = (String.Length)(runs)
	 		let last = len - 1

	 		let lastChar = (String.At)(runs, last)
	 		let firstChar = (String.At)(runs, 0)

	 		if (firstChar == `"`) * ((lastChar == `"`) == false) {
	 			raise "unterminated string"
	 		}
	 		
	 		return [ |> Type: TokenString, Value: ((String.Substring)(runs, 1, last)) <| ]
  	}
 <| )

AddParserRule(false, |>
  Id: "PFalse",
  AdvanceToken: true,
  Rule: fun(p) {
    return ParserCheck(p, TokenKeyword, "FALSE")
  },
  Parse: fun(p) {
    "Literal at 0 - false"
    return [2, 0]
  }
<| )

AddParserRule(false, |>
  Id: "PTrue",
  AdvanceToken: true,
  Rule: fun(p) {
    return ParserCheck(p, TokenKeyword, "TRUE")
  },
  Parse: fun(p) {
  "Literal at 0 - false"
    return [2, 1]
  }
<| )

AddParserRule(false, |>
	Id: "ParseStr",
	Rule: fun(p) {
		return TokenType((ParserPeek(p))) == TokenString
	},
	Parse: fun(p) {
      	return (ParserAppendLiteral(p, |>
      	    LiteralType: StringLiteral,
      	    Value: TokenValue((ParserAdvance(p)))
      	<| ))
	}
<| )

AddParserRule(false, |>
	Id: "ParseNum",
	Rule: fun(p) {
		return TokenType((ParserPeek(p))) == TokenNumber
	},
	Parse: fun(p) {
      	return (ParserAppendLiteral(p, |>
      	    LiteralType: IntLiteral,
      	    Value: (Int.Parse)(TokenValue((ParserAdvance(p))))
      	<| ))
	}
<| )

`AddParserRule(false, |>
	Id: "ParseObj",
	AdvanceToken: true,
	Rule: fun (p) = ParserCheck(p, TokenOperator, "LEFT_BRACE"),
	Parse: fun (p) {
    let entries = []

    let parseObjectEntries(p, currentEntries) {
        if (ParserMatch(p, TokenOperator, "RIGHT_BRACE")) {
            return currentEntries
        }

        let entry = [ (ParserParse(p)) ]

        if ((ParserMatch(p, TokenOperator, "COLON")) == false) {
            raise "expected colon to separate key and value"
        }

        entry = (Array.AppendAll)(entry, (ParserParse(p)))
        currentEntries = (Array.Append)(currentEntries, entry)

        if (ParserMatch(p, TokenOperator, "COMMA")) {
            return parseObjectEntries(p, currentEntries)
        } else {
            if ((ParserMatch(p, TokenOperator, "RIGHT_BRACE")) == false) {
                raise "expected closing operator for object"
            }
            return currentEntries
        }
    }

    if (ParserMatch(p, TokenOperator, "RIGHT_BRACE")) {
        entries = parseObjectEntries(p, entries)
    }

    return ParserAppendLiteral(p, |> LiteralType: ObjLiteral, Value: entries <| )
	}
<| )`

AddParserRule(false, |>
	Id: "ParseArr",
	AdvanceToken: true,
	Rule: fun (p) = ParserCheck(p, TokenOperator, "LEFT_BRACKET"),
	Parse: fun (p) {
        let entries = [ ]

        printLn("y0")

        if ((ParserMatch(p, TokenOperator, "RIGHT_BRACKET")) == false) {

            printLn("d0")

            for {
                let entry = ParserParse(p)

                printLn("d1")

                if (Result.IsResult)(entry) {
                    raise entry
                }

                printLn("d2")
                printLn(entry)


                entries = (Array.AppendAll)(entries, entry)

                if ((ParserMatch(p, TokenOperator, "COMMA")) == false) {
            printLn("d3.1")

                    break
                }

            printLn("d3")

            }

                if (ParserMatch(p, TokenOperator, "RIGHT_BRACKET")) {
            printLn("d4")

                    raise "expected closing operator for object"
                }
        }

        println("y1")

        return ParserAppendLiteral(p, |> LiteralType: ListLiteral, Value: entries <| )
	}
<| )